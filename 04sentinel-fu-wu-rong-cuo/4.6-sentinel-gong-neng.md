# 4.6 Sentinel功能

## 4.6.1 流控规则

流量控制，其原理是监控应用流量的QPS(每秒查询率) 或并发线程数等指标，当达到指定的阈值时对流 量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。&#x20;

第1步: 点击簇点链路，我们就可以看到访问过的接口地址，然后点击对应的流控按钮，进入流控规则配 置页面。新增流控规则界面如下:

![](<../.gitbook/assets/image (13).png>)

**资源名**：唯一名称，默认是请求路径，可自定义&#x20;

**针对来源**：指定对哪个微服务进行限流，默认指default，意思是不区分来源，全部限制&#x20;

**阈值类型单机阈值**：

* QPS（每秒请求数量）: 当调用该接口的QPS达到阈值的时候，进行限流
* 线程数：当调用该接口的线程数达到阈值的时候，进行限流

**是否集群**：暂不需要集群&#x20;

接下来我们以QPS为例来研究限流规则的配置。

### 4.6.1.1 简单配置

我们先做一个简单配置，设置阈值类型为QPS，单机阈值为3。即每秒请求量大于3的时候开始限流。接 下来，在流控规则页面就可以看到这个配置。

![](<../.gitbook/assets/image (56).png>)

### 4.6.1.2 配置流控模式

点击上面设置流控规则的**编辑**按钮，然后在编辑页面点击**高级选项**，会看到有流控模式一栏

![](<../.gitbook/assets/image (42).png>)

**sentinel共有三种流控模式，分别是**：&#x20;

* 直接（默认）：接口达到限流条件时，开启限流
* 关联：当关联的资源达到限流条件时，开启限流 \[适合做应用让步]
* 链路：当从某个接口过来的资源达到限流条件时，开启限流

下面呢分别演示三种模式：

* **直接流控模式** 直接流控模式是最简单的模式，当指定的接口达到限流条件时开启限流。上面案例使用的就是直接流控模式。&#x20;
* **关联流控模式** 关联流控模式指的是，当指定接口关联的接口达到限流条件时，开启对指定接口开启限流。

第1步：配置限流规则,将流控模式设置为关联，关联资源设置为的 `/order/message2`。

![](<../.gitbook/assets/image (22).png>)

<img src="../.gitbook/assets/image (53).png" alt="" data-size="original">

第二步：使用postman工具对 `/order/message/2` 进行测试

然后访问 `/order/message1` 查看结果，发现被限流。

* **链路流控模式** 链路流控模式指的是，当从某个接口过来的资源达到限流条件时，开启限流。它的功能有点类似于针对 来源配置项，区别在于：针对来源是针对上级微服务，而链路流控是针对上级接口，也就是说它的粒度 更细。

### 4.6.1.3 配置流控效果

* **快速失败（默认）**: 直接失败，抛出异常，不做任何额外的处理，是最简单的效果
* **Warm Up**：它从开始阈值到最大QPS阈值会有一个缓冲阶段，一开始的阈值是最大QPS阈值的 1/3，然后慢慢增长，直到最大阈值，适用于将突然增大的流量转换为缓步增长的场景。
* **排队等待**：让请求以均匀的速度通过，单机阈值为每秒通过数量，其余的排队等待； 它还会让设 置一个超时时间，当请求超过超时间时间还未处理，则会被丢弃

## 4.6.2 熔断规则

熔断规则就是设置当满足什么条件的时候，对服务进行降级。

Sentinel提供了三个衡量条件：&#x20;

* 平均响应时间 ：当资源的平均响应时间超过阈值（以 ms 为单位）之后，资源进入准降级状态。 如果接下来 1s 内持续进入 5 个请求，它们的 RT都持续超过这个阈值，那么在接下的时间窗口 （以 s 为单位）之内，就会对这个方法进行服务降级。
* 异常比例：当资源的每秒异常总数占通过量的比值超过阈值之后，资源进入降级状态，即在接下的 时间窗口（以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 \[0.0,1.0]。
* 异常数 ：当资源近 1 分钟的异常数目超过阈值之后会进行服务降级。注意由于统计时间窗口是分 钟级别的，若时间窗口小于 60s，则结束熔断状态后仍可能再进入熔断状态。

## 4.6.3 热点规则

热点参数流控规则是一种更细粒度的流控规则, 它允许将规则具体到参数上。&#x20;

**热点规则简单使用**&#x20;

第1步: 编写代码

```java
@RequestMapping("/order/message3")
@SentinelResource("message3")//注意这里必须使用这个注解标识,热点规则不生效
public String message3(String name, Integer age) {
    return name + age;
}
```

第2步: 配置热点规则

![](<../.gitbook/assets/image (47).png>)

第3步: 分别用两个参数访问,会发现只对第一个参数限流了

![](<../.gitbook/assets/image (5).png>)![](<../.gitbook/assets/image (14).png>)

**热点规则增强使用**

参数例外项允许对一个参数的具体值进行流控

编辑刚才定义的规则,增加参数例外项

![](<../.gitbook/assets/image (11).png>)

## 4.6.4 授权规则

很多时候，我们需要根据调用来源来判断该次请求是否允许放行，这时候可以使用 Sentinel 的来源访问 控制的功能。来源访问控制根据资源的请求来源（origin）限制资源是否通过：&#x20;

* 若配置白名单，则只有请求来源位于白名单内时才可通过；
* 若配置黑名单，则请求来源位于黑名单时不通过，其余的请求通过。

![](<../.gitbook/assets/image (36).png>)

**上面的资源名和授权类型不难理解，但是流控应用怎么填写呢？**

> 其实这个位置要填写的是来源标识，Sentinel提供了 RequestOriginParser 接口来处理来源。 只要Sentinel保护的接口资源被访问，Sentinel就会调用 RequestOriginParser 的实现类去解析 访问来源。

第1步: 自定义来源处理规则

```java
@Component
public class RequestOriginParserDefinition implements RequestOriginParser {
    @Override
    public String parseOrigin(HttpServletRequest httpServletRequest) {
        return httpServletRequest.getParameter("serviceName");
    }
}
```

第二步，增加controller方法

```java
@RequestMapping("/order/message4")
public String message4(String origin) {
    return origin;
}
```

第三步，授权规则配置，这里的配置意思是只有origin=app1 或 app2 不能访问（黑名单）

![](<../.gitbook/assets/image (48).png>)

第四步，访问浏览器测试

&#x20;![](<../.gitbook/assets/image (57).png>)

## 4.6.5 系统规则

系统保护规则是从应用级别的入口流量进行控制，从单台机器的总体 Load、RT、入口 QPS 、CPU使用 率和线程数五个维度监控应用数据，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。系统 保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量 (进入应用的流量) 生效。

* Load（仅对 Linux/Unix-like 机器生效）：当系统 load1 超过阈值，且系统当前的并发线程数超过 系统容量时才会触发系统保护。系统容量由系统的 maxQps \* minRt 计算得出。设定参考值一般 是 CPU cores \* 2.5。
* RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。
* 线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。
* 入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。
* CPU使用率：当单台机器上所有入口流量的 CPU使用率达到阈值即触发系统保护.

